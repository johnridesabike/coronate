{"version":3,"sources":["jsx/utility.jsx.js","chess-tourney/match.js","chess-tourney/player.js","chess-tourney/roster.js","chess-tourney/scores.js","chess-tourney/pairing.js","chess-tourney/round.js","chess-tourney/tournament.js","chess-tourney/config.js","jsx/players.jsx.js","jsx/tourney-setup.jsx.js","jsx/round.jsx.js","jsx/tournament.jsx.js","App.jsx.js","serviceWorker.js","index.js"],"names":["MainNav","_ref","children","react_default","a","createElement","className","NavItem","_ref2","name","action","classNames","isOpen","role","tabIndex","onClick","onKeyPress","calcRatings","match","whiteElo","players","getEloRank","blackElo","scoreExpected","getExpected","origRating","newRating","updateRating","result","map","rating","forEach","player","i","Object","freeze","round","importObj","tourney","ref_tourney","_importObj$players","slicedToArray","black","white","roster","getPlayerById","id","ref_round","warnings","ideal","reverse","blackWon","whiteWon","draw","setResult","resetResult","toConsumableArray","isComplete","isBye","p","dummy","includes","getColorInfo","color","getPlayerColor","indexOf","getPlayerInfo","getWhiteInfo","getBlackInfo","byeValue","matchCount","createPlayer","arguments","length","undefined","firstName","lastName","K","EloRank","hasHadBye","getPlayersByOpponent","dummyPlayer","toJSON","key","isReference","all","inactive","getActive","filter","importPlayerById","globalRoster","playerId","push","importPlayerIdsList","playerIdList","importPlayer","importPlayerList","playerList","deactivatePlayer","activatePlayer","splice","removePlayer","canRemovePlayer","removePlayerById","getMatchesByPlayer","canRemovePlayerById","setByIdList","playerManager","list","currentIds","toAdd","toRemove","pId","playerScoreList","roundId","playerScore","score","scoreList","reduce","b","playerScoreCum","runningScore","cumScores","playerScoreListNoByes","totalScore","playerColorBalance","modifiedMedian","solkoff","scores","opponent","sort","pop","shift","finalScore","playerOppScoreCum","oppScores","calcStandings","tieBreaks","tieBreak","m","active","standingsFlat","standing","method","funcName","sortFunc","firstBy","thenBy","standingsTree","runningRank","sf","player1","player2","scoreTypes","getOwnPropertyNames","areEqual","areScoresEqual","avoidMeetingTwicePriority","sameScoresPriority","differentHalfPriority","differentDueColorPriority","maxPriority","byeMatch","potentialMatches","matches","reducedResults","dueColor","ref_prevRound","playerColor","playerData","colorBalance","opponentHistory","upperHalf","Array","from","Set","byePlayer","byeQueue","byePlayerData","pd","last","createMatch","playersWithScore","chunk","playerDatum","allMatches","ignore","src","playerMatches","scoreDiff","priority","Math","abs","ceil","concat","blossom","p1Id","p2Id","p1","p2","pair","matched","roundList","getMatchByPlayer","theMatch","addPlayer","hasBye","removeMatch","matchData","pairPlayers","index","cloneDeep","config","isNewRoundReady","times","getNumOfRounds","log2","newRound","createRound","removeRound","Error","r","addPlayerToByeQueue","removePlayerFromByeQueue","setByeQueue","byQueue","assign","createRoster","roundData","moveTieBreak","methodId","newPos","movedMethod","noCircRefs","value","startsWith","Players","_useState","useState","_useState2","setRoster","newPlayerDefault","_useState3","_useState4","newPlayer","setNewPlayer","updateField","event","update","target","delPlayer","dataset","rosterTable","data-id","onSubmit","preventDefault","type","onChange","required","TourneySetup","setPlayerList","isSelecting","setIsSelecting","PlayerSelect","TourneyManager","pImports","setPImports","useEffect","toggleCheck","Number","react","checked","disabled","_ref3","_useState5","_useState6","byeList","byeDrop","byeSignUp","Options","_ref4","_useState7","_useState8","tbOptions","setTbOptions","tbToggle","pos","tbMove","dir","newTbOptions","data-pos","aria-label","RoundContainer","setRoundList","Round","NewRound","colSpan","RoundMatch","info","rawBalance","oppList","infoBox","setInfoBox","ratingDiff","setRatingDiff","PlayerInfo","numeral","format","_ref5","TournamentList","tourneyList","setTourneyList","openTourney","setOpenTourney","newTourneyDefaults","newTourneyData","setNewTourneyData","selectTourney","content","Tournament","createTournament","keys","roundNums","setRoundNums","esm","roundNum","Standings","rank","j","demoData","slice","Boolean","window","location","hostname","ReactDOM","render","tourneylist","lastId","addPlayers","playersData","loadPlayerData","data","createPlayerManager","currentView","setCurrentView","setViewList","viewList","document","getElementById","href","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2d32ad1f.chunk.js","sourcesContent":["import React from \"react\";\n\nexport function MainNav({children}) {\n    return (\n        <nav className=\"main-nav\">\n            {children}\n        </nav>\n    );\n}\n\nexport function NavItem({name, action, isOpen}) {\n    let classNames = \"main-nav__item\";\n    if (isOpen) {\n        classNames += \" is-open\";\n    }\n    return (\n        <span className={classNames} role=\"menuitem\" tabIndex=\"0\"\n            onClick={action} onKeyPress={action}>\n            {name}\n        </span>\n    );\n}","/**\n * Update the ratings for a match based on their ratings when the match began\n * and the match result. See the `elo-rank` NPM package for more information.\n * @param {object} match The `match` object.\n * @returns {object} The `match` object.\n */\nfunction calcRatings(match) {\n    let whiteElo = match.players[0].getEloRank();\n    let blackElo = match.players[1].getEloRank();\n    const FLOOR = 100;\n    let scoreExpected = [\n        whiteElo.getExpected(match.origRating[0], match.origRating[1]),\n        blackElo.getExpected(match.origRating[1], match.origRating[0])\n    ];\n    match.newRating = [\n        whiteElo.updateRating(\n            scoreExpected[0],\n            match.result[0],\n            match.origRating[0]\n        ),\n        blackElo.updateRating(\n            scoreExpected[1],\n            match.result[1],\n            match.origRating[1]\n        )\n    ];\n    match.newRating = match.newRating.map(\n        (rating) => (\n            (rating < FLOOR)\n            ? FLOOR\n            : rating\n        )\n    );\n    match.players.forEach(function (player, i) {\n        player.rating = match.newRating[i];\n    });\n    return match;\n}\n\n/**\n * Create an object representing a match in a tournament.\n * @param {object} round The round containing the match.\n * @param {object} black The `player` object for white.\n * @param {object} white The `player` object for black.\n */\nfunction createMatch(round, importObj) {\n    let tourney = round.ref_tourney;\n    let [black, white] = importObj.players;\n    // If the players are ID numbers, get their referant objects.\n    if (typeof black === \"number\") {\n        black = tourney.roster.getPlayerById(black);\n    }\n    if (typeof white === \"number\") {\n        white = tourney.roster.getPlayerById(white);\n    }\n    const match = {\n        id: importObj.id || 0,\n        /**\n         * @property {object} ref_round A reference to the round containing\n         * this match.\n         */\n        ref_round: round,\n        /**\n         * @property {object} ref_tourney A reference to the tournament\n         * containing this match.\n         */\n        ref_tourney: tourney,\n        /**\n         * @property {string} warnings Any warnings about the match, e.g. if\n         * there was a pairing error.\n         */\n        warnings: importObj.warnings || \"\",\n        /**\n         * @property {array} players The pair of `Player` objects. White is at\n         * index `0` and black is at index `1`.\n         */\n        players: [white, black],\n        /**\n         * @property {array} result the scores for the match. A loss is `0`, a\n         * win is `1`, and a draw is `0.5`. White is at index `0` and black is\n         * at index `1`.\n         */\n        result: importObj.result || [0, 0],\n        /**\n         * @property {array} origRating the cached ratings from when the match\n         * began. White is at index `0` and black is at index `1`.\n         */\n        origRating: importObj.origRating || [white.rating, black.rating],\n        /**\n         * @property {array} newRating the updated ratings after the match ends.\n         * White is at index `0` and black is at index `1`.\n         */\n        newRating: importObj.newRating || [white.rating, black.rating],\n        /**\n         * @property {number} ideal How ideal this matchup was, based on the\n         * maximum matching algorithm.\n         */\n        ideal: importObj.ideal || 0,\n        /**\n         * Switch white and black.\n         * @returns {object} This `match` object.\n         */\n        reverse() {\n            match.players.reverse();\n            match.result.reverse();\n            match.origRating.reverse();\n            match.newRating.reverse();\n            return match;\n        },\n        /**\n         * Set black as the winner and updates ratings.\n         * @returns {object} This `match` object.\n         */\n        blackWon() {\n            match.result = [0, 1];\n            calcRatings(match);\n            return match;\n        },\n        /**\n         * Set white as the winner and updates ratings.\n         * @returns {object} This `match` object.\n         */\n        whiteWon() {\n            match.result = [1, 0];\n            calcRatings(match);\n            return match;\n        },\n        /**\n         * Set the result as a draw and updates ratings.\n         * @returns {object} This `match` object.\n         */\n        draw() {\n            match.result = [0.5, 0.5];\n            calcRatings(match);\n            return match;\n        },\n        setResult(result) {\n            if (result !== match.result) {\n                match.result = result;\n                if (result[0] + result[1] === 0) {\n                    match.resetResult();\n                } else {\n                    calcRatings(match);\n                }\n            }\n            return match;\n        },\n        /**\n         * Resets the score and the rating updates.\n         * @returns {object} This `match` object.\n         */\n        resetResult() {\n            match.result = [0, 0];\n            match.newRating = [...match.origRating];\n            match.players[0].rating = match.newRating[0];\n            match.players[1].rating = match.newRating[1];\n            return match;\n        },\n        /**\n         * Get whether or not the match is over.\n         * @returns {bool} `True` if complete, `false` if incomplete.\n         */\n        isComplete() {\n            return match.result[0] + match.result[1] !== 0;\n        },\n        /**\n         * Get whether this is a bye match.\n         * @returns {bool} `True` if it's a bye match, `false` if not.\n         */\n        isBye() {\n            let dummies = match.players.map((p) => p.dummy);\n            return dummies.includes(true);\n        },\n        /**\n         * Get all of the match data for a specific player color.\n         * @param {number} color `0` for white and `1` for black.\n         * @returns {object} A container for data: the `player` object,\n         * `result`, `origRating`, and `newRating`.\n         */\n        getColorInfo(color) {\n            return {\n                player: match.players[color],\n                result: match.result[color],\n                origRating: match.origRating[color],\n                newRating: match.newRating[color]\n            };\n        },\n        /**\n         * Get the color ID of a player.\n         * @param {object} player A `player` object.\n         * @returns {number} `0` for white, `1` for black, and `-1` if the\n         * player isn't found in the match.\n         */\n        getPlayerColor(player) {\n            return match.players.indexOf(player);\n        },\n        /**\n         * A shortcut for using `match.getPlayerColor()` and\n         * `match.getColorInfo()` together.\n         * @param {object} player A `player` object.\n         * @returns {object} See `matchGetPlayerColor()`.\n         */\n        getPlayerInfo(player) {\n            return match.getColorInfo(match.getPlayerColor(player));\n        },\n        /**\n         * A shortcut for `match.getColorInfo()` for white.\n         * @returns {object} See `match.getColorInfo()`\n         */\n        getWhiteInfo() {\n            return match.getColorInfo(0);\n        },\n        /**\n         * A shortcut for `match.getColorInfo()` for black.\n         * @returns {object} See `match.getColorInfo()`\n         */\n        getBlackInfo() {\n            return match.getColorInfo(1);\n        }\n    };\n    // set bye rounds\n    if (match.players[0].dummy) {\n        match.result = [0, tourney.byeValue];\n    } else if (match.players[1].dummy) {\n        match.result = [tourney.byeValue, 0];\n    }\n    match.players.forEach(function (player) {\n        // This is stored statically so it's available even if data on past\n        // matches isn't. Be sure to safely decrement it when deleting match\n        // history.\n        player.matchCount += 1;\n    });\n    return match;\n}\n\nexport default Object.freeze(createMatch);\n","import EloRank from \"elo-rank\";\n\n/**\n * Represents an indivudal player. Call it with `createPlayer(\"John\", ...)` or\n * `createPlayer({firstName: \"John\", ...})`. The latter is convenient for\n * converting JSON objects.\n * @param {object} firstName Either the person's first name or an object\n * containing all the parameters.\n * @param {string} lastName  The person's last name.\n * @param {int}    rating    The person's Elo rating.\n */\nfunction createPlayer(importObj = {}) {\n    const player = {\n        /**\n         * @property {number} id The ID number of the player. Used mainly for\n         * JSON serialization.\n         */\n        id: importObj.id || 0,\n        /**\n         * @property {string} firstName The person's first name.\n         */\n        firstName: importObj.firstName || \"\",\n        /**\n         * @property {string} lastName The person's last name.\n         */\n        lastName: importObj.lastName || \"\",\n        /**\n         * @property {number} rating The person's Elo rating.\n         */\n        rating: importObj.rating || 0,\n        /**\n         * @property {bool} dummy If true, this player won't count in certain\n         * scorings.\n         */\n        dummy: importObj.dummy || false,\n        /**\n         * @property {number} matchCount Number of games the rating is based on.\n         */\n        matchCount: importObj.matchCount || 0,\n        /**\n         * Create an Elo calculator with an updated K-factor. See the `elo-rank`\n         * NPM package for more information.\n         * @param {object} tourney The current tournament.\n         * @returns {object} An `EloRank` object.\n         */\n        getEloRank() {\n            const ne = player.matchCount || 1;\n            const K = (800 / ne);\n            return new EloRank(K);\n        },\n        /**\n         * Get if a player has had a bye round.\n         * @param {object} tourney The current tournament.\n         * @returns {bool} True if the player has had a bye round, false if not.\n         * TODO: move this to the tournament object?\n         */\n        hasHadBye(tourney) {\n            return tourney.getPlayersByOpponent(player).includes(dummyPlayer);\n        },\n        toJSON(key) {\n            if (key && player.isReference) {\n                return player.id;\n            } else {\n                return player;\n            }\n        }\n    };\n    return player;\n}\n\n/**\n * A stand-in for bye matches.\n * @constant {object} dummyPlayer\n */\nconst dummyPlayer = Object.freeze(\n    createPlayer(\n        {\n            id: -1,\n            firstName: \"Bye\",\n            dummy: true,\n            rating: 0\n        }\n    )\n);\n\nfunction createPlayerManager(importObj = {}) {\n    const roster = {\n        roster: importObj.roster || [],\n        lastId: importObj.lastId || -1,\n        /**\n         * Add a player to the roster.\n         * @param {object} player The player object to add.\n         * @returns {object} This created player object.\n         */\n        addPlayer(playerData) {\n            playerData.id = roster.lastId + 1;\n            roster.lastId = playerData.id;\n            let player = createPlayer(playerData);\n            roster.roster.push(player);\n            return player;\n        },\n        /**\n         * Add a list of players to the roster.\n         * @param {array} players A list of players to add.\n         * @returns {array} The list of created player objects.\n         */\n        addPlayers(playersData) {\n            let newPlayerList = playersData.map(\n                (player) => roster.addPlayer(player)\n            );\n            return newPlayerList;\n        },\n        getPlayerById(id) {\n            return roster.roster.filter((p) => p.id === id)[0];\n        },\n        loadPlayerData(data) {\n            roster.roster = data.map(\n                (player) => createPlayer(player)\n            );\n        },\n        delPlayer(playerId) {\n            let index = roster.roster.map(\n                (p) => p.id\n            ).indexOf(\n                Number(playerId)\n            );\n            if (index === -1) {\n                return null;\n            }\n            let player = roster.roster.splice(index, 1);\n            return player;\n        }\n    };\n    if (importObj.playerData) {\n        roster.roster = roster.addPlayers(importObj.playerData);\n    }\n    return roster;\n}\n\nexport {dummyPlayer, createPlayer, createPlayerManager};","import {createPlayer} from \"./player\";\n/**\n * Create a roster object which manages a tournament's players.\n * @param {object} tourney The roster's tournament.\n * @param {array}  players A list of player objects.\n * @returns {object} The roster object.\n */\nfunction createRoster(tourney, importObj = null) {\n    const roster = {\n        /**\n         * @property {object} ref_tourney A reference to the tournemnt\n         * containing this match.\n         */\n        ref_tourney: tourney,\n        /**\n         * @param {array} all A list of all of the players.\n         */\n        all: [],\n        /**\n         * @param {array} inactive A list of the players who won't be paired in\n         * future rounds.\n         */\n        inactive: [],\n        /**\n         * Get a list of players to be paired.\n         * @returns {array} A list of the active players.\n         */\n        getActive() {\n            return roster.all.filter((i) => !roster.inactive.includes(i));\n        },\n        importPlayerById(globalRoster, playerId) {\n            let player = globalRoster.getPlayerById(playerId);\n            roster.all.push(player);\n            return roster;\n        },\n        importPlayerIdsList(playerIdList) {\n            playerIdList.map((id) => roster.importPlayer(id));\n            return roster;\n        },\n        importPlayerList(playerList) {\n            roster.all = playerList;\n            return roster;\n        },\n        /**\n         * Remove a player from the active roster. This player won't be placed\n         * in future rounds.\n         * @param {object} player The player object.\n         * @returns {object} This roster object.\n         */\n        deactivatePlayer(player) {\n            roster.inactive.push(player);\n            return roster;\n        },\n        /**\n         * Move an inactive player to the active roster to be placed in future\n         * rounds.\n         * @param {object} player The player object.\n         * @returns {object} This roster object.\n         */\n        activatePlayer(player) {\n            roster.inactive.splice(roster.inactive.indexOf(player), 1);\n            return roster;\n        },\n        /**\n         * Remove a player from the roster completely.\n         * @param {object} player The player object.\n         * @returns {object} This roster object.\n         */\n        removePlayer(player) {\n            if (roster.canRemovePlayer(player)) {\n                return null; // TODO: add a helpful error message\n            }\n            delete roster.all[roster.all.indexOf(player)];\n            return roster;\n        },\n        removePlayerById(playerId) {\n            roster.removePlayer(roster.getPlayerById(playerId));\n            return roster;\n        },\n        getPlayerById(id) {\n            return roster.all.filter((p) => p.id === id)[0];\n        },\n        canRemovePlayer(player) {\n            return (roster.ref_tourney.getMatchesByPlayer(player).length > 0);\n        },\n        canRemovePlayerById(id) {\n            return roster.canRemovePlayer(roster.getPlayerById(id));\n        },\n        setByIdList(playerManager, list) {\n            const currentIds = roster.all.map((p) => p.id);\n            const toAdd = list.filter((id) => !currentIds.includes(id));\n            const toRemove = currentIds.filter((id) => !list.includes(id));\n            toAdd.forEach((id) => roster.importPlayerById(playerManager, id));\n            toRemove.forEach((id) => roster.removePlayerById(id));\n        }\n    };\n    // Importing JSON-parsed data\n    if (importObj) {\n        // Turn the player IDs into player objects\n        importObj.all.forEach(\n            (pId) => roster.importPlayer(pId)\n        );\n        roster.inactive = importObj.inactive.map(\n            (pId) => roster.getPlayerById(pId)\n        );\n    }\n    return roster;\n}\n\nexport default Object.freeze(createRoster);","import {firstBy} from \"thenby\";\n/**\n * Get a list of all of a player's scores from each match.\n * @param {Player} player\n * @returns {array} the list of scores\n */\nfunction playerScoreList(tourney, player, roundId = null) {\n    return tourney.getMatchesByPlayer(player, roundId).map(\n        (match) => match.result[match.players.indexOf(player)]\n    );\n}\n\n// Maybe merge this with the other function?\nfunction playerScoreListNoByes(tourney, player, roundId = null) {\n    return tourney.getMatchesByPlayer(\n        player,\n        roundId\n    ).filter(\n        (match) => !match.isBye()\n    ).map(\n        (match) => match.result[match.players.indexOf(player)]\n    );\n}\n\n/**\n * Get the total score of a player after a given round.\n * @param {Player} player\n * @param {number} roundId\n */\nfunction playerScore(tourney, player, roundId = null) {\n    var score = 0;\n    var scoreList = playerScoreList(tourney, player, roundId);\n    if (scoreList.length > 0) {\n        score = scoreList.reduce((a, b) => a + b);\n    }\n    return score;\n}\n\n/**\n * Get the cumulative score of a player\n * @param {Player} player\n * @param {number} roundId\n */\nfunction playerScoreCum(tourney, player, roundId = null) {\n    var runningScore = 0;\n    var cumScores = [];\n    var scores = playerScoreListNoByes(tourney, player, roundId);\n    scores.forEach(function (score) {\n        runningScore += score;\n        cumScores.push(runningScore);\n    });\n    var totalScore = 0;\n    if (cumScores.length !== 0) {\n        totalScore = cumScores.reduce((a, b) => a + b);\n    }\n    return totalScore;\n}\n\n/**\n * Calculate a player's color balance\n * @param {Player} player\n * @param {Int}    round The ID of the highest round to consider\n * @returns {Int} A negative number means they played as white more. A positive\n * number means they played as black more.\n */\nfunction playerColorBalance(tourney, player, roundId = null) {\n    var color = 0;\n    tourney.getMatchesByPlayer(player, roundId).filter(\n        (match) => !match.isBye()\n    ).forEach(\n        function (match) {\n            if (match.players[0] === player) {\n                color += -1;\n            } else if (match.players[1] === player) {\n                color += 1;\n            }\n        }\n    );\n    return color;\n}\n\n/**\n * Gets the modified median factor defined in USCF  34E1\n * @param {Player} player\n * @param {number} roundId\n */\nfunction modifiedMedian(tourney, player, roundId = null, solkoff = false) {\n    // get all of the opponent's scores\n    var scores = tourney.getPlayersByOpponent(\n        player,\n        roundId\n    ).filter(\n        (opponent) => !opponent.dummy\n    ).map(\n        (opponent) => playerScore(tourney, opponent, roundId)\n    );\n    //sort them, then remove the first and last items\n    scores.sort();\n    if (!solkoff) {\n        scores.pop();\n        scores.shift();\n    }\n    var finalScore = 0;\n    if (scores.length > 0) {\n        finalScore = scores.reduce((a, b) => a + b);\n    }\n    return finalScore;\n}\n\n/**\n * A shortcut for passing the `solkoff` variable to `modifiedMedian`.\n * @param {Player} player\n * @param {number} roundId\n */\nfunction solkoff(tourney, player, roundId = null) {\n    return modifiedMedian(tourney, player, roundId, true);\n}\n\nfunction playerOppScoreCum(tourney, player, roundId = null) {\n    const opponents = tourney.getPlayersByOpponent(\n        player,\n        roundId\n    ).filter(\n        (opponent) => !opponent.dummy\n    );\n    var oppScores = opponents.map((p) => playerScoreCum(tourney, p, roundId));\n    var score = 0;\n    if (oppScores.length !== 0) {\n        score = oppScores.reduce((a, b) => a + b);\n    }\n    return score;\n}\n\nfunction areScoresEqual(player1, player2) {\n    const scoreTypes = Object.getOwnPropertyNames(player1);\n    var areEqual = true;\n    scoreTypes.forEach(function (score) {\n        if (score !== \"player\" && player1[score] !== player2[score]) {\n            areEqual = false;\n        }\n    });\n    return areEqual;\n}\n\nfunction getTbFunc(funcName) {\n    const tieBreakMethods = {\n        modifiedMedian,\n        playerColorBalance,\n        playerOppScoreCum,\n        playerScoreCum,\n        solkoff\n    };\n    return tieBreakMethods[funcName];\n}\n\n/**\n * Sort the standings by score, see USCF tie-break rules from  34.\n * @param {number} roundId\n * @returns {Array} The sorted list of players\n */\nfunction calcStandings(tourney, roundId = null) {\n    const tieBreaks = tourney.tieBreak.filter((m) => m.active);\n    const standingsFlat = tourney.roster.all.map(function (player) {\n        var standing = {\n            player: player,\n            score: playerScore(tourney, player, roundId)\n        };\n        tieBreaks.forEach(function (method) {\n            standing[method.name] = getTbFunc(\n                method.funcName\n            )(tourney, player, roundId);\n        });\n        return standing;\n    });\n    var sortFunc = firstBy((player) => player.score, -1);\n    tieBreaks.forEach(function (method) {\n        sortFunc = sortFunc.thenBy((player) => player[method.funcName], -1);\n    });\n    standingsFlat.sort(sortFunc);\n    const standingsTree = [];\n    var runningRank = 0;\n    standingsFlat.forEach(function (player, i, sf) {\n        if (i !== 0) { // we can't compare the first player with a previous one\n            const prevPlayer = sf[i - 1];\n            if (!areScoresEqual(player, prevPlayer)) {\n                runningRank += 1;\n            }\n        }\n        if (!standingsTree[runningRank]) {\n            standingsTree[runningRank] = [];\n        }\n        standingsTree[runningRank].push(player);\n    });\n    return standingsTree;\n}\n\nexport default Object.freeze({\n    calcStandings,\n    modifiedMedian,\n    playerColorBalance,\n    playerOppScoreCum,\n    playerScore,\n    playerScoreCum,\n    playerScoreList,\n    solkoff\n});","import {firstBy} from \"thenby\";\nimport {chunk, last} from \"lodash\";\nimport blossom from \"edmonds-blossom\";\nimport createMatch from \"./match\";\nimport scores from \"./scores\";\nimport {dummyPlayer} from \"./player\";\n\n/**\n * TODO: These probably need to be tweaked a lot.\n */\n/**\n * @constant avoidMeetingTwicePriority The weight given to avoid players\n * meeting twice. This is the highest priority. (USCF  27A1)\n */\nconst avoidMeetingTwicePriority = 20;\n/**\n * @constant sameScoresPriority The weight given to match players with\n * equal scores. This gets muliplied against a ratio taken from the distance\n * between each player's score. For example, if the tournament has players\n * scoring 0, 1, 2, and 3, and if a player scoring 1 gets compared with a\n * player scoring 3, then their `sameScoresPriority` will be reduced by 50%.\n * (`(3 - 1) / 4 = 0.5`) (USCF  27A2)\n */\nconst sameScoresPriority = 16;\n/**\n * @constant differentHalfPriority The weight given to match players in lower\n * versus upper halves. This is only applied to players being matched within\n * the same score group. (USCF  27A3)\n */\nconst differentHalfPriority = 2;\n/**\n * @constant differentDueColorPriority The weight given to match players with\n * opposite due colors. (USCF  27A4 and  27A5)\n */\nconst differentDueColorPriority = 1;\n\nconst maxPriority = (\n    avoidMeetingTwicePriority\n    + sameScoresPriority\n    + differentHalfPriority\n    + differentDueColorPriority\n);\n\n/**\n * Creates pairings according to the rules specified in USCF  27,  28,\n * and  29. This is a work in progress and does not account for all of the\n * rules yet.\n * @param {object} round The round object.\n * @returns {array} The list of matches.\n */\nfunction pairPlayers(round) {\n    let byeMatch;\n    let potentialMatches;\n    let matches;\n    let results;\n    let reducedResults;\n    const tourney = round.ref_tourney;\n    const dueColor = function (player) {\n        if (!round.ref_prevRound) {\n            return null;\n        }\n        let color = 0;\n        let prevColor = round.ref_prevRound.playerColor(player);\n        if (prevColor === 0) {\n            color = 1;\n        }\n        return color;\n    };\n    let playerData = round.roster.map(function (player, id) {\n        return {\n            player: player,\n            id: id,\n            score: scores.playerScore(tourney, player, round.id),\n            dueColor: dueColor(player),\n            colorBalance: scores.playerColorBalance(tourney, player),\n            opponentHistory: tourney.getPlayersByOpponent(player),\n            upperHalf: false\n        };\n    });\n    const scoreList = Array.from(new Set(playerData.map((p) => p.score)));\n    scoreList.sort();\n    // Sort the data so matchups default to order by score and rating.\n    playerData.sort(\n        firstBy((p) => p.score, -1).thenBy((p) => p.player.rating, -1)\n    );\n    /**\n     * Create an array of blossom-compatible weighted matchups. This returns\n     * an array of each potential match, formatted like so: [idOfPlayer1,\n     * idOfPlayer2, priority]. A higher priority means a more likely matchup.\n     * Use it in `Array.prototype.reduce()`.\n     * @param {array} allMatches The running list of all possible matchups.\n     * @param {object} player1 The data for the first player.\n     * @param {number} ignore The index of the player.\n     * @param {array} src The original array.\n     */\n    const matchupReducer = function (allMatches, player1, ignore, src) {\n        let opponents = src.filter((p) => p !== player1);\n        let playerMatches = opponents.map(function (player2) {\n            let priority = 0;\n            let scoreDiff;\n            if (!player1.opponentHistory.includes(player2.player)) {\n                priority += avoidMeetingTwicePriority;\n            }\n            // Calculate the \"distance\" between their scores and multiply that\n            // against the `sameScoresPriority` constant.\n            scoreDiff = Math.abs(\n                scoreList.indexOf(player1.score)\n                - scoreList.indexOf(player2.score)\n            );\n            scoreDiff = (scoreList.length - scoreDiff) / scoreList.length;\n            priority += sameScoresPriority * scoreDiff;\n            // Only include `differentHalfPriority` if they're in the same\n            // score group.\n            if (player1.score === player2.score) {\n                if (player1.upperHalf !== player2.upperHalf) {\n                    priority += differentHalfPriority;\n                }\n            }\n            if (player1.dueColor === null) {\n                priority += differentDueColorPriority;\n            } else if (player1.dueColor !== player2.dueColor) {\n                priority += differentDueColorPriority;\n            }\n            return [player1.id, player2.id, Math.ceil(priority)];\n        });\n        allMatches = allMatches.concat(playerMatches);\n        return allMatches;\n    };\n\n    // If there's an odd number of players, time to assign a bye.\n    if (playerData.length % 2 !== 0) {\n        // Get the next person in line from bye signups.\n        let byePlayer = tourney.byeQueue.filter(\n            (p) => !p.hasHadBye(tourney)\n        )[0];\n        let byePlayerData = playerData.filter(\n            (pd) => pd.player === byePlayer\n        )[0];\n        // If there isn't anyone on the list, assign a bye to the lowest-rated\n        // player in the lowest score group. (USCF  29L2.)\n        if (!byePlayerData) {\n            byePlayerData = last(\n                playerData.filter(\n                    (p) => !p.player.hasHadBye(tourney)\n                )\n            );\n        }\n        // In the impossible situation that *everyone* has played a bye round\n        // previously, then just pick the last player.\n        if (!byePlayerData) {\n            byePlayerData = last(playerData);\n        }\n        byeMatch = createMatch(\n            round,\n            {players: [byePlayerData.player, dummyPlayer]}\n        );\n        // Remove the bye'd player from the list so they won't be matched again.\n        playerData = playerData.filter((p) => p !== byePlayerData);\n    }\n    // Determine which players are in the upper and lower halves of their score\n    // groups.\n    scoreList.forEach(function (score) {\n        let playersWithScore = playerData.filter((pd) => pd.score === score);\n        playersWithScore.sort((pd) => pd.player.rating).reverse();\n        if (playersWithScore.length > 1) {\n            // The first chunk is the upper half\n            chunk(\n                playersWithScore,\n                playersWithScore.length / 2\n            )[0].forEach(function (playerDatum) {\n                playerDatum.upperHalf = true;\n            });\n        }\n    });\n    // Run the reducer. See `matchupReducer()` for info.\n    potentialMatches = playerData.reduce(matchupReducer, []);\n    // Feed all of the potential matches to Edmonds-blossom and let the\n    // algorithm work its magic. This returns an array where each index is the\n    // ID of one player and each value is the ID of the matched player.\n    results = blossom(potentialMatches);\n    // Translate those IDs into actual pairs of players.\n    reducedResults = results.reduce(\n        function (matches, p1Id, p2Id) {\n            // Filter out unmatched players. (Even though we removed the byes\n            // from the list, blossom will automatically include their missing\n            // IDs in its results.)\n            if (p1Id !== -1) {\n                let p1 = playerData.filter((p) => p.id === p1Id)[0];\n                let p2 = playerData.filter((p) => p.id === p2Id)[0];\n                let ideal = potentialMatches.filter(\n                    (pair) => pair[0] === p1Id && pair[1] === p2Id\n                )[0][2];\n                let matched = matches.map((pair) => pair[0]);\n                // let matched = matches.map((pair) => pair[0]);\n                // Blossom returns a lot of redundant matches. Check that this\n                // matchup wasn't already added.\n                if (!matched.includes(p1) && !matched.includes(p2)) {\n                    matches.push([p1, p2, ideal]);\n                }\n            }\n            return matches;\n        },\n        []\n    );\n    // Sort by net score and rating for board placement.\n    reducedResults.sort(\n        firstBy(\n            (pair) => pair[0].score + pair[1].score,\n            -1\n        ).thenBy(\n            (pair) => pair[0].rating + pair[1].rating,\n            -1\n        )\n    );\n    // Turn the results into new match objects.\n    matches = reducedResults.map(\n        function (pair) {\n            const player1 = pair[0];\n            const player2 = pair[1];\n            const ideal = pair[2];\n            const match = createMatch(\n                round,\n                {players: [player1.player, player2.player]}\n            );\n            match.ideal = ideal / maxPriority;\n            // A quick-and-easy way to keep colors mostly equal.\n            if (player1.colorBalance > player2.colorBalance) {\n                match.reverse();\n            }\n            // When the match isn't ideal, include a warning.\n            if (player1.opponentHistory.includes(player2.player)) {\n                match.warnings += (\n                    \" \" + player1.player.firstName\n                    + \" and \" + player2.player.firstName\n                    + \" have played previously.\"\n                );\n            }\n            [player1, player2].forEach(function (player) {\n                if (Math.abs(player.colorBalance) > 2) {\n                    match.warnings += (\n                        \" \" + player.player.firstName\n                        + \"'s color balance is off\"\n                    );\n                }\n            });\n            return match;\n        }\n    );\n    // The bye match always gets added last so as not to affect the numbering.\n    if (byeMatch) {\n        matches.push(byeMatch);\n    }\n    return matches;\n}\n\nexport default Object.freeze(pairPlayers);","import {dummyPlayer} from \"./player\";\nimport {last} from \"lodash\";\nimport pairPlayers from \"./pairing\";\nimport createMatch from \"./match\";\n\n/**\n * Create an object to represent a round in a tournament.\n * @param {object} tourney The tournament containing the round.\n */\nfunction createRound(tourney, importObj = {}) {\n    const round = {\n        /**\n         * @property {number} id The ID number of the round.\n         */\n        id: (\n            (importObj.id !== undefined)\n            ? importObj.id\n            : tourney.roundList.length\n        ),\n        /**\n         * @property {object} ref_tourney A reference to the tournament\n         * containing this round.\n         */\n        ref_tourney: tourney,\n        /**\n         * @property {array} roster The list of players in this round.\n         */\n        roster: importObj.roster || tourney.roster.getActive(),\n        /**\n         * @property {object} prevRound The round previous to this one.\n         */\n        ref_prevRound: importObj.ref_prevRound || last(tourney.roundList),\n        /**\n         * @property {array} matches The list of match objects.\n         */\n        matches: importObj.matches || null,\n        /**\n         * Get whether or not all of the matches in this round have completed.\n         * @returns {bool} `True` if they have all completed, `false` if they\n         * haven't.\n         */\n        isComplete() {\n            return !round.matches.map((m) => m.isComplete()).includes(false);\n        },\n        /**\n         * Get the match player has played in.\n         * @param {object} player The player.\n         * @returns {?object} The match object or `null` if no match is\n         * found.\n         */\n        getMatchByPlayer(player) {\n            let theMatch = null;\n            round.matches.forEach(function (match) {\n                if (match.players.includes(player)) {\n                    theMatch = match;\n                }\n            });\n            return theMatch;\n        },\n        /**\n         * Get the color of a player for this round.\n         * @param {object} player The player.\n         * @returns {number} `0` for white, `1` for black, or `-1` if the player\n         * wasn't found.\n         */\n        playerColor(player) {\n            let color = -1;\n            const match = round.getMatchByPlayer(player);\n            if (match) {\n                color = match.getPlayerColor(player);\n            }\n            return color;\n        },\n        /**\n         * Add a player to the round.\n         * TODO: I don't think this is used.\n         * @param {object} player The player.\n         * @returns {object} this round.\n         */\n        addPlayer(player) {\n            round.players.push(player);\n            return round;\n        },\n        /**\n         * Get whether or not this round has a bye round.\n         * TODO: I don't thin this is used.\n         * @returns {bool} `True` if it does, `false` if it doesn't.\n         */\n        hasBye() {\n            return round.roster.includes(dummyPlayer);\n        },\n        /**\n         * Remove a match. This undoes the results of the match.\n         * @param {number|object} match The object or ID of the match.\n         * @returns {object} This round object.\n         */\n        removeMatch(match) {\n            if (typeof match === \"number\") {\n                match = round.matches[match];\n            }\n            match.resetResult();\n            match.players.forEach(function (player) {\n                player.matchCount -= 1;\n            });\n            round.matches = round.matches.filter((m) => m !== match);\n            return round;\n        },\n        toJSON(key) {\n            if (key === \"prevRound\") {\n                return round.id;\n            } else {\n                return round;\n            }\n        }\n    };\n    round.roster = round.roster.map(function (player) {\n        if (typeof player === \"number\") {\n            return tourney.roster.getPlayerById(player);\n        } else {\n            return player;\n        }\n    });\n    if (round.matches) {\n        // If match data was imported, then init it.\n        round.matches = round.matches.map(\n            (matchData) => createMatch(round, matchData)\n        );\n    } else {\n        round.matches = pairPlayers(round);\n    }\n    round.matches.forEach(function (match, index) {\n        match.id = index;\n    });\n    return round;\n}\n\nexport default Object.freeze(createRound);","import createRoster from \"./roster\";\nimport createRound from \"./round\";\nimport {last, times, cloneDeep} from \"lodash\";\nimport config from \"./default-config.json\";\n\nfunction createTournament(importObj = \"\") {\n    let name;\n    if (typeof importObj === \"string\") {\n        name = importObj;\n    } else {\n        name = importObj.name;\n    }\n    const tourney = {\n        id: 0,\n        /**\n         * @property {string} name The display name of the tournament.\n         */\n        name: name,\n        /**\n         * @property {array} roundList The list of rounds.\n         */\n        roundList: [],\n        /**\n         * @property {number} byeValue How many points a bye is worth. USCF\n         * suggests either 1 or 0.5.\n         */\n        byeValue: 1,\n        /**\n         * @property {array} byeQueue A list of players signed up for bye\n         * rounds, if byes are necessary.\n         */\n        byeQueue: [],\n        /**\n         * @property {object} roster The roster object.\n         */\n        roster: null,\n        tieBreak: cloneDeep(config.tieBreak),\n        /**\n         * Get if a new round is ready or not.\n         * @returns {bool} `True` if a round is ready, `false` if not.\n         */\n        isNewRoundReady() {\n            let isReady = false;\n            if (tourney.roundList.length > 0) {\n                isReady = last(tourney.roundList).isComplete();\n            } else {\n                isReady = (tourney.roster.all.length > 0);\n            }\n            return isReady;\n        },\n        /**\n         * Get a list of matches containing a particular player.\n         * @param {object} player The specified player.\n         * @param {number} roundId The round to fetch up to.\n         * @returns {array} The list of matches.\n         */\n        getMatchesByPlayer(player, roundId = null) {\n            if (roundId === null) {\n                roundId = tourney.roundList.length;\n            }\n            let matches = [];\n            times(roundId + 1, function (i) {\n                if (tourney.roundList[i] !== undefined) {\n                    tourney.roundList[i].matches.forEach(function (match) {\n                        if (match.players.indexOf(player) !== -1) {\n                            matches.push(match);\n                        }\n                    });\n                }\n            });\n            return matches;\n        },\n        /**\n         * Get a list of players who have played a specified player.\n         * @param {object} player The specified player.\n         * @param {number} roundId The round to fetch up to.\n         * @returns {array} A list of player objects.\n         */\n        getPlayersByOpponent(opponent, roundId = null) {\n            let players = [];\n            tourney.getMatchesByPlayer(opponent, roundId).forEach(\n                function (match) {\n                    players = players.concat(\n                        match.players.filter(\n                            (player) => player !== opponent\n                        )\n                    );\n                }\n            );\n            return players;\n        },\n        /**\n         * Get the minimum number of rounds based on the number of players.\n         * @returns {number} The number of rounds.\n         */\n        getNumOfRounds() {\n            let roundId = Math.ceil(\n                Math.log2(tourney.roster.getActive().length)\n            );\n            if (roundId === -Infinity) {\n                roundId = 0;\n            }\n            return roundId;\n        },\n        /**\n         * Create a new round and add it to the round list.\n         * @returns {object} The new round object.\n         */\n        newRound() {\n            if (!tourney.isNewRoundReady()) {\n                return false;\n            }\n            let newRound = createRound(tourney);\n            tourney.roundList.push(newRound);\n            return newRound;\n        },\n        removeRound(round) {\n            if (typeof round === \"number\" || typeof round === \"string\") {\n                round = tourney.roundList[round];\n            }\n            if (round !== last(tourney.roundList)) {\n                throw new Error(\"You can only remove the last round\");\n            }\n            round.matches.forEach(function (match) {\n                round.removeMatch(match);\n            });\n            tourney.roundList = tourney.roundList.filter((r) => r !== round);\n            return tourney;\n        },\n        /**\n         * Add a player to the bye queue.\n         * @param {object} player The player object.\n         * @returns {object} This tournament object.\n         */\n        addPlayerToByeQueue(player) {\n            tourney.byeQueue.push(player);\n            return tourney;\n        },\n        /**\n         * Remove a player from the bye queue.\n         * @param {object} player The player object.\n         * @returns {object} This tournament object.\n         */\n        removePlayerFromByeQueue(player) {\n            tourney.byeQueue = tourney.byeQueue.filter((p) => p !== player);\n            return tourney;\n        },\n        setByeQueue(playerList) {\n            tourney.byQueue = playerList;\n            return tourney;\n        }\n    };\n    // Importing JSON-parsed data\n    if (typeof importObj === \"object\") {\n        Object.assign(tourney, importObj);\n    }\n    if (tourney.roster) {\n        // If roster data was imported, then init it.\n        tourney.roster = createRoster(tourney, tourney.roster);\n    } else {\n        // create a blank roster\n        tourney.roster = createRoster(tourney);\n    }\n    if (tourney.roundList.length >= 0) {\n        // If round data was imported, then init it.\n        tourney.roundList = tourney.roundList.reduce(\n            function (roundList, roundData) {\n                roundData.ref_prevRound = last(roundList) || null;\n                roundList.push(createRound(tourney, roundData));\n                return roundList;\n            },\n            []\n        );\n    }\n    return tourney;\n}\n\nexport default Object.freeze(createTournament);\n","import config from \"./default-config.json\";\n\n/**\n * Moves a specific tie-break method to a new priority.\n * @function moveTieBreak\n * @param {number} methodId The key ID for the target tie-break method.\n * @param {number} newPos The new position to move the method do.\n * @returns {?array} The modified array of tie-break methods if successful, or\n * null on failure.\n */\nconfig.moveTieBreak = function (methodId, newPos) {\n    if (newPos < 0 || newPos > config.tieBreak.length - 1) {\n        return null;\n    }\n    if (!config.tieBreak[methodId]) {\n        return null;\n    }\n    let movedMethod = config.tieBreak.splice(methodId, 1)[0];\n    config.tieBreak.splice(newPos, 0, movedMethod);\n    return config.tieBreak;\n};\n\n/**\n * Removes circular references with `JSON.stringify()`.\n */\nconfig.noCircRefs = function (key, value) {\n    if (key.startsWith(\"ref_\")) {\n        return undefined;\n    } else {\n        return value;\n    }\n};\n\n\nexport default Object.freeze(config);","import React, {useState} from \"react\";\n\nexport function Players({playerManager}) {\n    const [roster, setRoster] = useState(playerManager.roster);\n    const newPlayerDefault = {firstName: \"\", lastName: \"\", rating: 1200};\n    const [newPlayer, setNewPlayer] = useState(newPlayerDefault);\n    const handleSubmit = function (event) {\n        event.preventDefault();\n        playerManager.addPlayer(newPlayer);\n        setNewPlayer(newPlayerDefault);\n        setRoster([...playerManager.roster]);\n    };\n    const updateField = function (event) {\n        let update = {};\n        update[event.target.name] = event.target.value\n        setNewPlayer(Object.assign({}, newPlayer, update));\n    };\n    const delPlayer = function (event) {\n        playerManager.delPlayer(event.target.dataset.id);\n        setRoster([...playerManager.roster]);\n    };\n    let rosterTable = \"\";\n    if (roster.length > 0) {\n        rosterTable = \n        <table>\n            <caption>Demo Roster</caption>\n            <thead>\n                <tr>\n                <th>First name</th>\n                <th>Last name</th>\n                <th>Rating</th>\n                <th></th>\n                <th></th>\n                </tr>\n            </thead>\n            <tbody>\n                {roster.map((player) =>\n                <tr key={player.id} >\n                    <td className=\"table__player\">{player.firstName}</td>\n                    <td className=\"table__player\">{player.lastName}</td>\n                    <td className=\"table__number\">{player.rating}</td>\n                    <td>\n                        <button \n                            data-id={player.id}\n                            onClick={delPlayer}>\n                            x\n                        </button>\n                    </td>\n                    <td></td>\n                </tr>\n                )}\n            </tbody>\n        </table>\n    }\n    return (\n        <div className=\"roster\">\n            {rosterTable}\n            <p>\n                Add your own players:\n            </p>\n            <form onSubmit={handleSubmit}>\n                <p>\n                    <label>\n                        First name&nbsp;\n                        <input type=\"text\" name=\"firstName\" onChange={updateField}\n                            value={newPlayer.firstName} required />\n                    </label>\n                </p>\n                <p>\n                    <label>\n                        Last name&nbsp;\n                        <input type=\"text\" name=\"lastName\" onChange={updateField}\n                            value={newPlayer.lastName} required />\n                    </label>\n                </p>\n                <p>\n                    <label>\n                        Rating&nbsp;\n                        <input type=\"number\" name=\"rating\" onChange={updateField}\n                            value={newPlayer.rating} required />\n                    </label>\n                </p>\n                <p>\n                    <input type=\"submit\" value=\"Add\"/>\n                </p>\n            </form>\n        </div>\n    );\n}\n","import React, {useState, useEffect, Fragment} from \"react\";\n\nexport function TourneySetup({tourney, playerManager, playerList, setPlayerList}) {\n    const [isSelecting, setIsSelecting] = useState(playerList.length === 0);\n    if (isSelecting) {\n        return <PlayerSelect\n            key={tourney.id}\n            tourney={tourney} \n            playerManager={playerManager}\n            setIsSelecting={setIsSelecting}\n            setPlayerList={setPlayerList}\n            />\n    } else {\n        return <TourneyManager\n            key={tourney.id}\n            tourney={tourney}\n            setIsSelecting={setIsSelecting} />\n    }\n}\n\nfunction PlayerSelect({playerManager, tourney, setIsSelecting, setPlayerList}) {\n    const [pImports, setPImports] = useState(tourney.roster.all.map((p) => p.id));\n    useEffect(function () {\n        tourney.roster.setByIdList(playerManager, pImports);\n        setPlayerList([...tourney.roster.all])\n    }, [pImports]);\n    const toggleCheck = function (event) {\n        const id = Number(event.target.dataset.id);\n        if (pImports.includes(id)) {\n            setPImports(pImports.filter((i) => i!== id));\n        } else {\n            setPImports([id].concat(pImports));\n        }\n    };\n    const globalRoster = playerManager.roster;\n    return (\n        <Fragment>\n            <p>\n                Select your players.\n            </p>\n            <ul>\n            {globalRoster.map((player) =>\n                <li key={player.id}>\n                    <input type=\"checkbox\" data-id={player.id}\n                        onChange={toggleCheck}\n                        checked={pImports.includes(player.id)}\n                        disabled={tourney.roster.canRemovePlayerById(player.id)} />\n                    {player.firstName} {player.lastName}\n                </li>    \n            )}\n            </ul>\n            <button onClick={() => setPImports(globalRoster.map((p) => p.id))}>\n                Select all\n            </button>\n            <button onClick={() => setPImports([])}>\n                Select none\n            </button>\n            <button onClick={() => setIsSelecting(false)}>\n                Done\n            </button>\n        </Fragment>\n    );\n}\n\nexport function TourneyManager({tourney, setIsSelecting}) {\n    const [byeQueue, setByeQueue] = useState(tourney.byeQueue);\n    const byeSignUp = (player) => {\n        setByeQueue([...byeQueue,...[player]]);\n    };\n    const byeDrop = (player) => {\n        setByeQueue(byeQueue.filter((p) => p !== player));\n    };\n    useEffect(function () {\n        tourney.setByeQueue(byeQueue.map((id) => tourney.roster.getPlayerById(id)));\n    }, [byeQueue]);\n    let byeList = \"\";\n    if (byeQueue.length > 0) {\n        byeList = (\n            <Fragment>\n                <h2>Bye signups:</h2>\n                <ol>\n                {byeQueue.map((player) =>  \n                    <li key={player.id}\n                        className={player.hasHadBye(tourney) ? \"inactive\" : \"active\"}>\n                        {player.firstName}\n                        <button\n                            onClick={() => byeDrop(player)}\n                            disabled={player.hasHadBye(tourney)}>\n                            x\n                        </button>\n                    </li>\n                )}\n                </ol>\n            </Fragment>\n        )\n    }\n    let rosterTable = (\n        <table>\n            <caption>Roster</caption>\n            <thead>\n                <tr>\n                <th>First name</th>\n                <th>Rating</th>\n                <th>Rounds played</th>\n                <th></th>\n                </tr>\n            </thead>\n            <tbody>\n                {tourney.roster.all.map((player) =>\n                <tr key={player.id} \n                    className={tourney.roster.inactive.includes(player) ? \"inactive\" : \"active\"}>\n                    <td className=\"table__player\">{player.firstName}</td>\n                    <td className=\"table__number\">{player.rating}</td>\n                    <td className=\"table__number\">\n                    {tourney.getMatchesByPlayer(player).length}\n                    </td>\n                    <td>\n                    {tourney.roster.getActive().length % 2 !== 0 &&\n                        (tourney.byeQueue.includes(player) || player.hasHadBye(tourney)\n                        ? <button disabled>Bye</button>\n                        : <button onClick={() => byeSignUp(player)}>Bye</button>)\n                    }\n                    </td>\n                </tr>\n                )}\n            </tbody>\n        </table>\n    );\n    return (\n        <Fragment>\n            {rosterTable}\n            {byeList}\n            <button onClick={() => setIsSelecting(true)}>\n                Select players\n            </button>\n            <button>\n                New round\n            </button>\n            <Options key={tourney.id} tourney={tourney} />\n        </Fragment>\n    );\n}\n\nfunction Options({tourney}) {\n    const [tbOptions, setTbOptions] = useState(tourney.tieBreak);\n    const tbToggle = (event) => {\n        let id = event.target.dataset.pos;\n        tbOptions[id].active = event.target.checked;\n        setTbOptions([...tbOptions]);\n    };\n    const tbMove = (pos, dir) => {\n        const newPos = pos + dir;\n        const newTbOptions = [...tbOptions];\n        const movedMethod = newTbOptions.splice(pos, 1)[0];\n        newTbOptions.splice(newPos, 0, movedMethod);\n        setTbOptions(newTbOptions);\n    };\n    useEffect(function () {\n        tourney.tieBreak = tbOptions\n    });\n    return (\n        <section>\n            <h3>Options</h3>\n            <h3>Tie break priority</h3>\n            <ol>\n            {tbOptions.map((method, i) => \n                <li key={method.funcName}>\n                    <input \n                        type=\"checkbox\"\n                        data-pos={i} \n                        checked={method.active} \n                        onChange={tbToggle}/>\n                    {method.name}\n                    <button onClick={() => tbMove(i, -1)} disabled={i === 0}>\n                        <span role=\"img\" aria-label=\"Move up\"></span>\n                    </button>\n                    <button onClick={() => tbMove(i, 1)}\n                        disabled={i === tbOptions.length - 1} >\n                        <span role=\"img\" aria-label=\"Move down\"></span>\n                    </button>\n                </li>\n            )}\n            </ol>\n        </section>\n    );\n}","import React, {useState, useEffect, Fragment} from \"react\";\nimport {scores} from \"../chess-tourney\";\nimport numeral from \"numeral\";\nimport \"../round.css\";\n\nexport function RoundContainer({tourney, round, roundList, setRoundList}) {\n    if (round) {\n        return <Round round={round} setRoundList={setRoundList} />\n    } else {\n        return <NewRound tourney={tourney} setRoundList={setRoundList} />\n    }\n}\n\nfunction NewRound({tourney, setRoundList}) {\n    const makeRound = function () {\n        tourney.newRound();\n        setRoundList([...tourney.roundList]);\n    };\n    if (tourney.isNewRoundReady()) {\n        return (\n            <button\n                onClick={makeRound}>\n                Make new round\n            </button>);\n    } else {\n        return <p>Complete the last round first.</p>\n    }\n}\n\nfunction Round({round, setRoundList}) {\n    const tourney = round.ref_tourney;\n    const [matches, setMatches] = useState(round.matches);\n    const delRound = function () {\n        tourney.removeRound(round);\n        setRoundList([...tourney.roundList]);\n    };\n    return (\n        <Fragment>\n            <table className=\"table__roster\">\n                <caption>Round {round.id + 1} results</caption>\n                <thead>\n                <tr>\n                    <th>#</th>\n                    <th colSpan=\"2\">White</th>\n                    <th>Draw</th>\n                    <th colSpan=\"2\">Black</th>\n                    <th></th>\n                </tr>\n                </thead>\n                <tbody>\n                {matches.map((match) =>\n                    <RoundMatch\n                        key={match.id} match={match} />\n                )}\n                </tbody>\n            </table>\n            <h2>Actions</h2>\n            <button\n                onClick={delRound}>\n                Delete round\n            </button>\n        </Fragment>\n    );\n}\n\nfunction RoundMatch({match}) {\n    // Getting info for the toggleable box\n    const round = match.ref_round;\n    const tourney = match.ref_tourney;\n    const white = match.getWhiteInfo();\n    const black = match.getBlackInfo();\n    [white, black].forEach(function (info) {\n        let rawBalance = scores.playerColorBalance(tourney, info.player, round.id);\n        let colorBalance = \"Even\";\n        if (rawBalance < 0) {\n            colorBalance = \"White +\" + Math.abs(rawBalance);\n        } else if (rawBalance > 0) {\n            colorBalance = \"Black +\" + rawBalance;\n        }\n        info.colorBalance = colorBalance;\n        info.score = scores.playerScore(tourney, info.player, round.id)\n        info.oppList = tourney.getPlayersByOpponent(info.player, round.id);\n    });\n    const [result, setResult] = useState(match.result);\n    const [infoBox, setInfoBox] = useState(false);\n    const [ratingDiff, setRatingDiff] = useState([\n        white.newRating - white.origRating,\n        black.newRating - black.origRating\n    ])\n    useEffect(function () {\n        match.setResult(result);\n        setRatingDiff([\n            match.getWhiteInfo().newRating - match.getWhiteInfo().origRating,\n            match.getBlackInfo().newRating - match.getBlackInfo().origRating\n        ])\n    }, [result]);\n    return (\n        <Fragment>\n            <tr className={match.isBye() ? \"inactive\" : \"\"}>\n                <td className=\"table__number\">{match.id + 1}</td>\n                <td className=\"table__player\">\n                    {white.player.firstName}\n                </td>\n                <td className=\"table__input\">\n                    <input \n                    type=\"radio\"\n                    checked={result[0] === 1}\n                    disabled={match.isBye()}\n                    onChange={() => setResult([1,0])} />\n                </td>\n                <td className=\"table__input\">\n                    <input \n                        type=\"radio\"\n                        checked={result[0] === 0.5}\n                        disabled={match.isBye()}\n                        onChange={() => setResult([0.5, 0.5])} />\n                </td>\n                <td className=\"table__input\">\n                    <input \n                        type=\"radio\"\n                        checked={result[1] === 1}\n                        disabled={match.isBye()}\n                        onChange={() => setResult([0, 1])} />\n                </td>\n                <td className=\"table__player\">\n                    {black.player.firstName}\n                </td>\n                <td>\n                    <button onClick={() => setInfoBox(!infoBox)}>\n                        ?\n                    </button>\n                    {match.warnings}\n                </td>\n            </tr>\n            {infoBox &&\n            <tr>\n                <td colSpan=\"3\">\n                    <PlayerInfo player={white} ratingDiff={ratingDiff[0]}/>\n                </td>\n                <td>Match ideal: {numeral(match.ideal).format(\"00%\")}</td>\n                <td colSpan=\"3\">\n                    <PlayerInfo player={black} ratingDiff={ratingDiff[1]}/>\n                </td>\n            </tr>\n            }\n        </Fragment>\n    );\n}\n\nfunction PlayerInfo({player, ratingDiff}) {\n    return (\n        <dl className=\"player-card\">\n            <dt>Score</dt>\n            <dd>{player.score}</dd>\n            <dt>Rating</dt>\n            <dd>\n                {player.origRating}\n                &nbsp;({numeral(ratingDiff).format(\"+0\")})\n            </dd>\n            <dt>Color balance</dt>\n            <dd>{player.colorBalance}</dd>\n            <dt>Opponent history</dt>\n            <dd>\n                <ol>\n                {player.oppList.map((opponent, i) =>\n                    <li key={i}>\n                    {opponent.firstName}\n                    </li>  \n                )}\n                </ol>\n            </dd>\n            <dt>Match ideal</dt>\n            <dd>\n                {}\n            </dd>\n        </dl>\n\n    );\n}","import React, {useState, useEffect, Fragment} from \"react\";\nimport { Tab, Tabs, TabList, TabPanel } from \"react-tabs\";\nimport \"react-tabs/style/react-tabs.css\";\nimport {createTournament, scores} from \"../chess-tourney\";\nimport {TourneySetup} from \"./tourney-setup.jsx\"\nimport {RoundContainer} from \"./round.jsx\";\n\nexport function TournamentList({playerManager, tourneyList, setTourneyList, openTourney, setOpenTourney}) {\n    const newTourneyDefaults = {name: \"The most epic tournament\"};\n    const [newTourneyData, setNewTourneyData] = useState(newTourneyDefaults);\n    const newTourney = function(event) {\n        event.preventDefault();\n        let tourney = createTournament(event.target.name.value);\n        tourney.id = tourneyList.length;\n        setTourneyList([...tourneyList,...[tourney]])\n        setNewTourneyData(newTourneyDefaults);\n        setOpenTourney(tourney)\n    };\n    const updateField = function (event) {\n        let update = {};\n        update[event.target.name] = event.target.value\n        setNewTourneyData(Object.assign({}, newTourneyData, update));\n    };\n    const selectTourney = function (event) {\n        const id = event.target.dataset.id;\n        setOpenTourney(tourneyList[id])\n    };\n    let content = \"\";\n    if (openTourney) {\n        content = \n        <Tournament \n        key={openTourney.id}\n        tourney={openTourney}\n        playerManager={playerManager}\n        setOpenTourney={setOpenTourney} />\n    } else {\n        content = \n        <Fragment>\n            {(tourneyList.length > 0)\n            ?\n                <ol>\n                    {tourneyList.map((tourney, i) => \n                        <li key={i} data-id={i}  tabIndex=\"0\" role=\"menuitem\"\n                            onClick={selectTourney} onKeyPress={selectTourney}>\n                            {tourney.name}\n                        </li>    \n                    )}\n                </ol>\n            :\n                <p>\n                    No tournaments added yet.\n                </p>\n            }\n            <form onSubmit={newTourney}>\n                <input type=\"text\" name=\"name\" value={newTourneyData.name}\n                    onChange={updateField} required />\n                <input type=\"submit\" value=\"New Tournament\" />\n            </form>\n        </Fragment>\n    }\n    return (\n        <main>\n            {content}\n        </main>\n    );\n}\n\nfunction Tournament({tourney, playerManager, setOpenTourney}) {\n    const [playerList, setPlayerList] = useState(tourney.roster.all);\n    const [roundNums, setRoundNums] = useState(\n        [...Array(tourney.getNumOfRounds()).keys()]\n    );\n    useEffect(function () {\n        setRoundNums([...Array(tourney.getNumOfRounds()).keys()]);\n    }, [playerList]);\n    const [roundList, setRoundList] = useState(tourney.roundList);\n    const isRoundReady = function (id) {\n        // we also return if it's the next available round so the user can begin it\n        return roundList[id] || id === roundList.length;\n    }\n    return (\n        <Tabs>\n            <button onClick={() => setOpenTourney(null)}>&lt; back</button>\n            <h2>{tourney.name}</h2>\n            <TabList>\n                <Tab>Setup</Tab>\n                <Tab disabled={playerList.length === 0}>Standings</Tab>\n                {roundNums.map((roundNum) => \n                    <Tab key={roundNum} disabled={!isRoundReady(roundNum)}>\n                        Round {roundNum + 1}\n                    </Tab>    \n                )}\n            </TabList>\n            <TabPanel>\n                <TourneySetup key={tourney.id} setPlayerList={setPlayerList}\n                    playerList={playerList}\n                    tourney={tourney} playerManager={playerManager}/>\n            </TabPanel>\n            <TabPanel>\n                <Standings tourney={tourney} />\n            </TabPanel>\n            {roundNums.map((roundNum) => \n                <TabPanel key={roundNum}>\n                    <RoundContainer key={roundNum} tourney={tourney}\n                        round={roundList[roundNum]} roundList={roundList}\n                        setRoundList={setRoundList} />\n                </TabPanel>\n            )}\n        </Tabs>\n    );\n}\n\nexport function Standings({tourney}) {\n    return (\n      <table>\n        <caption>Current Standings</caption>\n        <thead>\n          <tr>\n            <th></th>\n            <th>First name</th>\n            <th>Score</th>\n            {tourney.tieBreak.filter((m) => m.active).map((method, i) =>\n                <th key={i}>{method.name}</th>\n            )}\n          </tr>\n        </thead>\n        {scores.calcStandings(tourney).map((rank, i) => \n          <tbody key={i}>\n            {rank.map((player, j) => \n              <tr key={j}>\n                  <td>{i + 1}</td>\n                  <td>{player.player.firstName}</td>\n                  <td className=\"table__number\">{player.score}</td>\n                  {tourney.tieBreak.filter((m) => m.active).map((method, i) =>\n                      <td className=\"table__number\" key={i}>\n                          {player[method.name]}\n                      </td>\n                  )}\n              </tr>\n              )}\n          </tbody>\n        )}\n      </table>\n    );\n}\n","import React, { useState } from \"react\";\nimport \"./App.css\";\nimport {MainNav, NavItem} from \"./jsx/utility.jsx.js\"\nimport {createPlayerManager} from \"./chess-tourney\";\nimport {Players} from \"./jsx/players.jsx.js\";\nimport {TournamentList} from \"./jsx/tournament.jsx.js\";\nimport demoRoster from \"./demo-players.json\";\n\n// const defaultTournament = createTournament(\"CVL Winter Open\");\nconst demoData = {playerData: demoRoster.slice(0,16)}\n\nfunction App() {\n    const [tourneylist, setTourneyList] = useState([]);\n    const [openTourney, setOpenTourney] = useState(null);\n    const [playerManager, setPlayerManager] = useState(\n        createPlayerManager(demoData)\n    );\n    const [currentView, setCurrentView] = useState(0);\n    const setViewList = (id) => setCurrentView(id);\n    const viewList = [\n        <Players playerManager={playerManager} />,\n        <TournamentList playerManager={playerManager}\n            tourneyList={tourneylist} setTourneyList={setTourneyList}\n            openTourney={openTourney} setOpenTourney={setOpenTourney} />\n    ];\n    return (\n        <main>\n            <MainNav>\n                <NavItem name=\"Players\"\n                    action={() => setViewList(0)} isOpen={currentView === 0} />\n                <NavItem name=\"Tournaments\"\n                    action={() => setViewList(1)} isOpen={currentView === 1} />\n            </MainNav>\n            {viewList[currentView]}\n        </main>\n    );\n    // return (\n    //     <div className=\"tournament\">\n    //     <nav className=\"tabbar\">\n    //         <ul>\n    //         {tabList.map((tab, i) => \n    //             <li key={i}>\n    //             <button\n    //                 className=\"tab\"\n    //                 onClick={() => setCurrentTab(tab)}\n    //                 disabled={currentTab === tab} >\n    //                 {tab.name}\n    //             </button>\n    //             </li>\n    //         )}\n    //         <li>\n    //             <button \n    //             className=\"tab new_round\"\n    //             onClick={newRound} >\n    //             New Round\n    //             </button>\n    //         </li>\n    //         </ul>\n    //     </nav>\n    //     <h1>Chessahoochee: a chess tournament app</h1>\n    //     {currentTab.contents}\n    //     </div>\n    // );\n}\n\nfunction Caution() {\n    return (\n        <p>\n            <span role=\"img\" aria-label=\"waving hand\"></span>&nbsp;\n            This is an unstable demo build!\n            Want to help make it better? Head to the&nbsp;\n            <span role=\"img\" aria-label=\"finger pointing right\"></span>&nbsp;\n            <a href=\"https://github.com/johnridesabike/chessahoochee\">Git repository</a>.\n        </p>\n    );\n}\n\nexport {App, Caution};\n","/*jslint browser*/\n/*global process fetch*/\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets;\n      // see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport {App, Caution} from \"./App.jsx\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\nReactDOM.render(<Caution />, document.getElementById(\"caution\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}