// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as Belt_Set from "bs-platform/lib/es6/belt_Set.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Db$Coronate from "../../Db.bs.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";
import * as DemoData$Coronate from "../../DemoData.bs.js";
import * as TestData$Coronate from "../../TestData.bs.js";
import * as Data_Player$Coronate from "../../Data/Data_Player.bs.js";
import * as Data_Rounds$Coronate from "../../Data/Data_Rounds.bs.js";
import * as Data_Converters$Coronate from "../../Data/Data_Converters.bs.js";

function log2(num) {
  return Math.log(num) / Math.log(2.0);
}

var configData_avoidPairs = Belt_Set.mergeMany(TestData$Coronate.config.avoidPairs, Belt_Set.toArray(DemoData$Coronate.config.avoidPairs));

var configData_byeValue = TestData$Coronate.config.byeValue;

var configData_lastBackup = TestData$Coronate.config.lastBackup;

var configData = {
  avoidPairs: configData_avoidPairs,
  byeValue: configData_byeValue,
  lastBackup: configData_lastBackup
};

function merger(_key, a, b) {
  if (a !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(a));
  } else if (b !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(b));
  } else {
    return ;
  }
}

var tournamentData = Belt_MapString.merge(TestData$Coronate.tournaments, DemoData$Coronate.tournaments, merger);

var playerData = Belt_MapString.merge(TestData$Coronate.players, DemoData$Coronate.players, merger);

function calcNumOfRounds(playerCount) {
  var roundCount = Math.ceil(log2(playerCount));
  var match = roundCount !== Pervasives.neg_infinity;
  if (match) {
    return roundCount | 0;
  } else {
    return 0;
  }
}

function tournamentReducer(param, action) {
  return action;
}

function LoadTournament_mock(Props) {
  var children = Props.children;
  var tourneyId = Props.tourneyId;
  var match = React.useReducer(tournamentReducer, Belt_MapString.getExn(tournamentData, tourneyId));
  var tourney = match[0];
  var roundList = tourney.roundList;
  var playerIds = tourney.playerIds;
  var match$1 = Db$Coronate.useAllPlayers(/* () */0);
  var players = match$1[0];
  var activePlayers = Belt_MapString.keep(players, (function (id, param) {
          return Belt_List.has(playerIds, id, (function (prim, prim$1) {
                        return prim === prim$1;
                      }));
        }));
  var roundCount = calcNumOfRounds(Belt_MapString.size(activePlayers));
  var isItOver = Data_Rounds$Coronate.size(roundList) >= roundCount;
  var match$2 = Data_Rounds$Coronate.size(roundList) === 0;
  var isNewRoundReady = match$2 ? true : Data_Rounds$Coronate.isRoundComplete(roundList, activePlayers, Data_Rounds$Coronate.size(roundList) - 1 | 0);
  return Curry._1(children, {
              activePlayers: activePlayers,
              getPlayer: (function (param) {
                  return Data_Player$Coronate.getPlayerMaybe(players, param);
                }),
              isItOver: isItOver,
              isNewRoundReady: isNewRoundReady,
              players: players,
              playersDispatch: match$1[1],
              roundCount: roundCount,
              tourney: tourney,
              setTourney: match[1]
            });
}

function useRoundData(roundId, tournament) {
  var roundList = tournament.tourney.roundList;
  var activePlayers = tournament.activePlayers;
  var scoreData = React.useMemo((function () {
          return Data_Converters$Coronate.matches2ScoreData(Data_Rounds$Coronate.rounds2Matches(roundList, undefined, /* () */0));
        }), /* array */[roundList]);
  var round = Data_Rounds$Coronate.get(roundList, roundId);
  var isThisTheLastRound = roundId === Data_Rounds$Coronate.getLastKey(roundList);
  var unmatched;
  if (round !== undefined && isThisTheLastRound) {
    var matched = Data_Rounds$Coronate.Round.getMatched(Caml_option.valFromOption(round));
    unmatched = Belt_MapString.removeMany(activePlayers, matched);
  } else {
    unmatched = Belt_MapString.empty;
  }
  var unmatchedCount = Belt_MapString.size(unmatched);
  var match = unmatchedCount % 2 !== 0;
  var unmatchedWithDummy = match ? Belt_MapString.set(unmatched, Data_Player$Coronate.dummy_id, Curry._1(tournament.getPlayer, Data_Player$Coronate.dummy_id)) : unmatched;
  var activePlayersCount = Belt_MapString.size(activePlayers);
  return {
          activePlayersCount: activePlayersCount,
          scoreData: scoreData,
          unmatched: unmatched,
          unmatchedCount: unmatchedCount,
          unmatchedWithDummy: unmatchedWithDummy
        };
}

var make = LoadTournament_mock;

export {
  log2 ,
  configData ,
  merger ,
  tournamentData ,
  playerData ,
  calcNumOfRounds ,
  tournamentReducer ,
  make ,
  useRoundData ,
  
}
/* configData Not a pure module */
